-- | A little parser and pretty printer generator.
module AutoAST
  ( version12
  ) where

import Data.Char
import Data.List
import Text.Printf

data Term
  = NonTerminal String [(String, Expr)]
  | Terminal String
  deriving Eq

data Expr
  = One      Term
  | Many     Term
  | Sequence [Expr]
  | Token    String String
  deriving Eq

upper :: String -> String
upper (a:b) = toUpper a : b
upper [] = []

typeName :: Term -> String
typeName a = case a of
  NonTerminal a _ -> upper a
  Terminal    a   -> upper a

generate :: String -> [Term] -> String
generate name terms' =
     printf "-- Generated by AutoAST.\nmodule %s\n  ( %s  ) where\n" name exports
  ++ "\n"
  ++ "import Text.ParserCombinators.Poly.Lazy\n"
  ++ "\n"
  ++ concatMap dataType terms
  where
  terms = nub $ concatMap subTerms terms'
  exports = drop 4 $ concat [ printf "  , %-30s (..)\n" (typeName t) :: String | t <- terms ]

dataType :: Term -> String
dataType a = def ++ printer
  where
  def = case a of
    NonTerminal _ options -> printf "data %s\n  = %s\n" (typeName a) (drop 4 $ concat constructors)
      where
      constructors = [ printf "  | %s %s\n" (upper name) (typeArguments expr) :: String | (name, expr) <- options ]
    Terminal _ -> printf "data %s = %s\n\n" (typeName a) (typeName a) 

  printer = case a of
    NonTerminal _ options -> printf "instance Show %s where\n  show a = case a of\n    %s\n" (typeName a) (drop 4 $ concat constructors)
      where
      constructors = [ printf "    %s%s -> %s\n" (upper name) (concat [ " a" ++ show n | n <- [1 .. n - 1] ]) s :: String | (name, expr) <- options, let (n, s) = printExpr 1 expr ]
    Terminal a -> printf "instance Show %s where\n  show a = %s\n\n" (upper a) (show a)

subTerms :: Term -> [Term]
subTerms a = case a of
  NonTerminal _ b -> a : concatMap subTerms' (snd $ unzip b)
  Terminal _ -> [a]

subTerms' :: Expr -> [Term]
subTerms' a = case a of
  One      a -> subTerms a
  Many     a -> subTerms a
  Sequence a -> concatMap subTerms' a
  Token _ _  -> []

typeArguments :: Expr -> String
typeArguments a = case a of
  One      a -> typeName a
  Many     a -> "[" ++ typeName a ++ "]"
  Sequence a -> intercalate " " $ filter (not . null) $ map typeArguments a
  Token _ _  -> ""

printExpr :: Int -> Expr -> (Int, String)
printExpr n a = case a of
  One      a -> (n + 1, "show a" ++ show n)
  Many     a -> (n + 1, "drop 1 (concat [ \" \" ++ show a | a <- a" ++ show n ++ "])")
  Sequence a -> foldl (\ (n, s) a -> let (n', s') = printExpr n a in (n', if null s then s' else s ++ " ++ \" \" ++ " ++ s')) (n, "") a
  Token  _ a -> (n, show a)

many1 :: Term -> Expr
many1 a = Sequence [One a, Many a]

left :: Expr
left = Token "LeftParan" "("

right :: Expr
right = Token "RightParan" ")"

ident :: String -> Expr
ident a = Token ("Identifier \"" ++ a ++ "\"") a

fun_symb = NonTerminal "fun_symb"
  [ ("fun_symb_identifier", Sequence [left, many1 identifier, right])
  , ("fun_symb_arith_symb", One arith_symb)
  ]

{-
an_term = NonTerminal "an_term"
  [ ("an_term_base_term", One base_term)
  , ("an_term_base_term_", Sequence [left, One base_term, Many annotation, right])
  , ("an_term_fun", Sequence [left, One fun_symb, many1 an_term, Many annotation, right])
  , ("an_term_ite", Sequence [left, ident "ite", One an_formula, One an_term, Many annotation, right])
  ]

annotation = undefined
an_formula = undefined
base_term = undefined
-}
arith_symb = Terminal "arith_symb"
identifier = Terminal "identifer"

version12 :: String
version12 = generate "Language.SMTLIB.Version12" [fun_symb]

